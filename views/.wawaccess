wawaccess do
   
  ######################################################################## MATCHERS 
  
  # Recognizes existing folders only
  matcher :directory do
    File.directory?(File.join(folder, req_path)) and (
      File.exists?(File.join(folder, req_path, "index.whtml")) or
      File.exists?(File.join(folder, req_path, "index.wtpl"))
    )
  end
  
  # Recognizes any downloadable file (extension match and file
  # exists)
  matcher :downloadable do
    req_path =~ /\.(js|css|tar|gz|zip|jpg|gif|png|bmp|pdf)$/ and
    File.exists?(File.join(folder, req_path))
  end
  
  # Recognizes forms
  matcher :form do
    File.exists?(File.join(folder, "#{req_path}.form")) and 
    request.params.include?('jsrequest')
  end
  
  # Recognizes messages from javascript requester
  matcher :jsmessage do
    File.exists?(File.join(folder, "#{req_path}.msg")) and 
    request.params.include?('jsrequest')
  end
  
  # Recognizes messages from non-js requester
  matcher :nonjsmessage do
    File.exists?(File.join(folder, "#{req_path}.msg")) and 
    not(request.params.include?('jsrequest'))
  end
  
  # Recognizes pages that can be composed
  matcher :composable do
    ['wtpl', 'whtml'].any?{|ext|
      File.exists?(File.join(folder, "#{req_path}.#{ext}"))
    }
  end
  
  ######################################################################## SERVICE RULES 
  
  # REWRITING: / => /index
  # REWRITING: /folder_1/.../folder_n => /folder_1/.../folder_n/index
  match directory do
    apply "#{req_path}/index"
  end
  
  # RULE: downloadable -> static service
  match downloadable do
    static
  end
  
  # RULE: message -> static service
  match jsmessage do
    [ 200, 
      {'Content-Type' => 'text/html'},
      File.readlines(File.join(folder, "#{req_path}.msg")) ]
  end
  
  match form do
    template = File.join(wawaccess.root.folder, "#{req_path}.form")
    source = WLang::file_instantiate(template, default_wlang_context)
    [200, {'Content-Type' => 'text/html'}, [ source ]]
  end
  
  # RULE: no-js-message -> special service
  match nonjsmessage do
    context  = {
                :base           => Waw.config.web_base,
                :normalized_url => 'index',
                :page_name      => 'index',
                :stylesheets    => Dir[File.join(folder, "css", "*.css")].sort.collect{|file| file[folder.length..-1]},
                :scripts        => Dir[File.join(folder, "js", "*.js")].sort.collect{|file| file[folder.length..-1]},
                :classes        => ["views"],
                :body           => WLang::file_instantiate(File.join(folder, 'index.wtpl'), default_wlang_context),
                :message        => req_path,
                :title          => "UCLouvain ACM Student Chapter"
               }
    template = "templates/layout.wtpl"
    wlang template, context
  end
  
  # RULE: composable -> composed
  match composable do
    # Create the wlang context now
    context  = {:base           => "#{Waw.config.web_base}#{req_path}",
                :normalized_url => req_path,
                :page_name      => File.basename(req_path)}
    
    # Find the source file
    source_file = if File.exists?(File.join(folder, "#{req_path}.whtml"))
      File.join(folder, "#{req_path}.whtml")
    elsif File.exists?(File.join(folder, "#{req_path}.wtpl"))
      File.join(folder, "#{req_path}.wtpl")
    end
    
    # Create the css and js files
    current_folder = File.dirname(source_file)
    stylesheets, scripts, classes = [], [], []
    side_file = nil
    until current_folder == File.dirname(folder)
      # find stylesheets and scripts
      stylesheets.unshift Dir[File.join(current_folder, "css", "*.css")].sort.collect{|file| file[folder.length..-1]}
      scripts.unshift Dir[File.join(current_folder, "js", "*.js")].sort.collect{|file| file[folder.length..-1]}

      # extend css classes
      classes << File.basename(current_folder)
      
      # set side file
      if side_file.nil? and File.exists?(File.join(current_folder, "side.wtpl"))
        side_file = File.join(current_folder, "side.wtpl")
      end
      
      # continue
      current_folder = File.dirname(current_folder)
    end
    
    # Create the wlang context now
    context.merge!(:stylesheets    => stylesheets.flatten,
                   :scripts        => scripts.flatten,
                   :classes        => classes)
    
    # Set the page contents
    context[:body] = case File.extname(source_file)
      when '.whtml'
        File.read(source_file)
      when '.wtpl'
        WLang::file_instantiate(source_file, default_wlang_context.merge(context))
      else 
        ""
    end
    
    # Set the right menu
    unless side_file.nil?
      context[:side] = WLang::file_instantiate(side_file, default_wlang_context.merge(context))
    end
    
    # Set the page title
    context[:title] = if context[:body] =~ /^<h2>(.*?)<\/h2>/
       CGI::unescapeHTML($1).gsub("&mdash;", "-").gsub("&nbsp;", " ")
    else
      "UCLouvain ACM Student Chapter"
    end
    
    template = "templates/layout.wtpl"
    wlang template, context
  end
  
  ######################################################################## REWRITING RULES 
  
  match 'activites' do
    apply "activites/2009-2010"
  end
  match 'securite-vie-privee' do
    apply "activites/2009-2010/conferences/securite-vie-privee"
  end
  match 'olympiades' do
    apply "activites/2009-2010/olympiades"
  end
  match 'scienceinfuse' do
    apply "activites/2009-2010/scienceinfuse"
  end

  ######################################################################## MATCH ALL RULES
  
  # RULE: true -> 404 error
  match true do
    apply "404", 404
  end
  
end